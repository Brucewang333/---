

# 一.JS基础部分

## 1.JavaScript基础

### 1.组成

- ECMAScript:javascript语法
- DOM:页面文件对象模型
- BOM:浏览器对象模型

#### 1.ECMAScript

ECMAScript是由ECMA国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMAScript语言的实现和扩展。

ECMAScript : ECMAScript规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。

#### 2.DOM——文档对象模型

文档对象模型(Document Object Model，简称DOM）)，是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等)。

#### 3.BOM——浏览器对象模型

BOM(Browser ObjectModel，简称BOM)是指浏览器对象模型，它提供了独立于内容的、可以与**浏览器窗口进行互动的对象结构**。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。

### 2.变量

- 为什么需要变量?因为我们一些数据需要保存，所以需要变量
- 变量是什么?变量就是一个容器，用来存放数据的。方便我们以后使用里面的数据；
- 变量的本质是什么?变量是内存里的一块空间，用来存数据。
- 变量怎么使用的?我们使用变量的时候，一定要声明变量，然后赋值；声明变量本质是去内存申请空间；
- 什么是变量的初始化?声明变量并赋值我们称之为变量的初始化
- 变量命名规范有哪些？变量名尽量要规范，见名知意——驼峰命名法；区分哪些变量名不合法
- 交换2个变量值的思路?学会交换2个变量

### 3.数据类型

JavaScript是一种弱类型或者说动态语言。

JS把数据类型分为两类∶

- 简单数据类型( Number , string ,Boolean, Undefined,Null )
- 复杂数据类型( object)

| 简单数据类型 | 说明                                               | 默认值    |
| ------------ | -------------------------------------------------- | --------- |
| Number       | 数字型，包含整型值和浮点型值，如21、0.21           | 0         |
| Boolean      | 布尔值类型，如true , false，等价于1和0             | false     |
| String       | 字符串类型，如"张三”注意咱们js里面，字符串都带引号 | ""        |
| Undefined    | var a;声明了变量a但是没有给值，此时a = undefined   | undefined |
| Null         | var a = null;声明了变量a为空值                     | null      |

isNan(x)==>不是数字返回true,是数字返货false;

**遍历字符串**

> 1

```
//遍历字符串
exec 一般用于独立的动作一次性执行,返回 query(find()方法查询返回的是 data)
'Sname': new RegExp(.)//将关键词匹配
newData = results.filter((item) =>item.commodityIntroduction.match(RegExp(/i7/)));
```

### 4.数据类型转换

#### 1.转字符串类型

- num.toString()
- String(num)  //强制转换
- num+''

#### 2.转数字类型

- parseInt(str)//取整
- parseFloat(str)//保留小数 
- Number(str)//强制转换(str必须是数字型字符串否则返回NaN)
- 'str'-0=str//减乘除(str必须是数字型字符串)

数字类型字符串转数字："6"+0==>6

#### 3.转换为布尔值

- 代表空、否定的值会被转换为false ,如 " "、0、NaN、null、undefined
- 其余值都会被转换为true

### 5.标识符、关键字、保留字

#### 1.标识符

标识(zhi)符∶就是指开发人员为变量、属性、函数、参数取的名字。标识符不能是关键字或保留字。

#### 2.关键字

关键字∶是指JS本身已经使用了的字，不能再用它们充当变量名、方法名。
包括: break、case、catch、continue、default、delete、do、else、finally、for、function、if、in.instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with等。

#### 3.保留字

保留字︰实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。

包括: boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile等。

### 6.运算符

运算符( operator )也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。

JavaScript中常用的运算符有∶

- 算数运算符
- 递增和递减运算符
- 比较运算符
- 逻辑运算符
- 赋值运算符

#### 1.算术运算符

y=5，下面的表格解释了这些算术运算符：

| 运算符 | 描述         | 例子  | x 运算结果 | y 运算结果 |
| :----- | :----------- | :---- | :--------- | :--------- |
| +      | 加法         | x=y+2 | 7          | 5          |
| -      | 减法         | x=y-2 | 3          | 5          |
| *      | 乘法         | x=y*2 | 10         | 5          |
| /      | 除法         | x=y/2 | 2.5        | 5          |
| %      | 取模（余数） | x=y%2 | 1          | 5          |
| ++     | 自增         | x=++y | 6          | 6          |
| ++     | 后自增       | x=y++ | 5          | 6          |
| --     | 自减         | x=--y | 4          | 4          |
| --     | 后自减       | x=y-- | 5          | 4          |

#### 2.比较运算符

| 运算符 | 描述                                               |
| :----- | :------------------------------------------------- |
| ==     | 等于                                               |
| ===    | 全等于（值和数据类型均相等）                       |
| !=     | 不等于                                             |
| !==    | 不绝对等于（值和类型有一个不相等，或两个都不相等） |
| >      | 大于                                               |
| <      | 小于                                               |
| >=     | 大于或等于                                         |
| <=     | 小于或等于                                         |

#### 3.逻辑运算符

| 运算符 | 描述      | 例子                      |
| :----- | :-------- | :------------------------ |
| &&     | and（且） | (x < 10 && y > 1) 为 true |
| \|\|   | or（或）  | (x==5 \|\| y==5) 为 false |
| !      | not（非） | !(x==y) 为 true           |

**短路运算（逻辑中断)**

短路运算的原理∶当有多个表达式(值)时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;
1.逻辑与

```javascript
语法:表达式1&&表达式2&&表达式3
```

- **小结**：返回 值为假的表达式，没有则返回最后一个

2.逻辑或

```
语法:表达式1||表达式2||表达式3
```

**小结**：返回 值为真的表达式，没有则返回最后一个

#### 4.赋值运算符

给定 **x=10** 和 **y=5**，下面的表格解释了赋值运算符：

| 运算符 | 例子 | 等同于 | 运算结果 |
| :----- | :--- | :----- | :------- |
| =      | x=y  | x=y    | x=5      |
| +=     | x+=y | x=x+y  | x=15     |
| -=     | x-=y | x=x-y  | x=5      |
| *=     | x*=y | x=x*y  | x=50     |
| /=     | x/=y | x=x/y  | x=2      |
| %=     | x%=y | x=x%y  | x=0      |

#### 5.运算符优先级

| 优先级 | 运算符     | 顺序           |
| ------ | ---------- | -------------- |
| 1      | 小括号     | ()             |
| 2      | —元运算符  | ++ -- !        |
| 3      | 算数运算符 | 先*/%后+-      |
| 4      | 关系运算符 | `>` >= < <=    |
| 5      | 相等运算符 | ==  != === !== |
| 6      | 逻辑运算符 | 先&&后\|\|     |
| 7      | 赋值运算符 | =              |
| 8      | 逗号运算符 | ,              |

- 一元运算符里面的逻辑非优先级很高
- 逻辑与比逻辑或优先级高

## 2.JavaScript 流程控制

### 1.流程控制

在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。
简单理解︰流程控制就是来控制我们的代码按照什么结构顺序来执行
流程控制主要有三种结构，分别是**顺序结构**、**分支结构**和**循环结构**，这三种结构代表三种代码执行的顺序。

### 2.顺序流程控制

顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。

### 3.分支流程控制if 语句

#### 3.1分支结构

由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果

#### 3.2 if 语句

1.语法结构

```javascript
//条件成立执行代码，否则什么也不做
if(条件表达式){
//条件成立执行的代码语句
}
```

语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，一般情况下，会分割成一个一个的语句。

#### 3.3 if else语句(双分支语句)

1.语法结构

```javascript
//条件成立执行if里面代码，否则执行else里面的代码
if(条件表达式){
//[如果]条件成立执行的代码
}else {
//[否则]执行的代码
}
```

#### 3.4if else if 语句(多分支语句)

1.语法结构

```javascript
//适合于检查多重条件。
if(条件表达式1）{
	语句1;
} else if(条件表达式2){
	语句2;
}else if(条件表达式3){
	语句3;
} else {
//上述条件都不成立执行此处代码
}
```

#### 3.5三元表达式

三元表达式也能做一些简单的条件选择。有三元运算符组成的式子称为三元表达式

语法：

```javascript
判断表达式 ? 表达式1 :表达式2 //判断表达式为true返回表达式1;false返回表达式2
```

#### 3.6分支流程控制switch语句

##### 3.6.1语法结构

switch语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用switch。

```javascript
 switch (表达式) {
     case value1:
         执行语句1;
         break;
     case value2:
         执行语句2;
         break;
         ...
     default:
     执行最后的语句;
 }
```

##### 3.6.2 switch语句和if else if 语句的区别

- 一般情况下，它们两个语句可以相互替换
- switch..case语句通常处理case为比较确定值的情况，而if..else...语句更加灵活，常用于范围判断(大于、
  等于某个范围)
- switch语句进行条件判断后直接执行到程序的条件语句，效率更高。而if..else语句有几种条件，就得判断多
  少次。
- 当分支比较少时，if...else语句的执行效率比switch语句高。
- 当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。

### 4.循环流程控制

#### 1.循环

循环目的：在实际问题中，有许多具有**规律性的重复操作**，因此在程序中要完成这这类操作就需要**重复执行某些语句**

在Js 中，主要有三种类型的循环语句∶

- for循环
- while循环
- do...while循环

#### 2.for循环

在程序中，一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的终止条件。由循环体及循环的终止条件组成的语句，被称之为循环语句

**语法结构**

for循环主要用于把某些代码循环若干次，通常跟计数有关系。其语法结构如下∶

```javascript
for(初始化变量;条件表达式;操作表达式){
	//循环体
}
```

**断点调试:**
断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。
**断点调试可以帮我们观察程序的运行过程**

- 浏览器中按F12--> sources -->找到需要调试的文件-->在程序的某一行设置断点
- Watch:监视，通过watch可以监视变量的值的变化，非常的常用。
- F11:程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。
- 代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。
- 今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可，后面还会学到很多的代码调试技巧。

#### 3.双重for循环

#### 双重for循环概述

很多情况下，单层for循环并不能满足我们的需求，比如我们要打印一个5行5列的图形、打印一个倒直角三角形等，此时就可以通过循环嵌套来实现。

**循环嵌套**是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语句中，可以再嵌套一个for循环，这样的for循环语句我们称之为**双重for循环**。

#### for循环小结

- for循环可以重复执行某些相同代码
- for循环可以重复执行些许不同的代码，因为我们有计数器
- for循环可以重复执行某些操作，比如算术运算符加法操作
- 随着需求增加，双重for循环可以做更多、更好看的效果
- 双重for循环，外层循环一次，内层for循环全部执行
- for循环是循环条件和数字直接相关的循环
- 分析要比写代码更重要
- 一些核心算法想不到，但是要学会，分析它执行过程
- 举一反三，自己经常总结，做一些相似的案例

#### 4.while循环

while语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环while语句的语法结构如下∶

```javascript
while (条件表达式){
	//循环体代码
}
```

**执行思路:**

- 先执行条件表达式，如果结果为true，则执行循环体代码;
- 如果为false，则退出循环，执行后面代码②执行循环体代码
- 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循
  环条件为false 时，整个循环过程才会结束

#### 5.do while 循环

do... while语句其实是while语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环
do... while语句的语法结构如下∶

```javascript
do {
//循环体代码 – 条件表达式为 true 时重复执行循环体代码
} while (条件表达式) ;
```

**执行思路:**

- 先执行一次循环体代码

- 再执行条件表达式，如果结果为true，则继续执行循环体代码，如果为false，则退出循环，继续执行后面代码

  **注意∶先再执行循环体，再判断，我们会发现do...while循环语句至少会执行一次循环体代码**

#### 6.循环小结

- JS中循环有for . while、do while
- 三个循环很多情况下都可以相互替代使用
- 如果是用来计次数，跟数字相关的，三者使用基本相同，但是我们更喜欢用for
- while和do...while可以做更复杂的判断条件，比for循环灵活一些
- while和do...while执行顺序不一样，while先判断后执行，do...while先执行一次，再判断执行
- while和do...while执行次数不一样，do...while至少会执行一次循环体，而while 可能一次也不执行
- 实际工作中，**我们更常用for循环语句**，它写法更简洁直观，所以这个要重点学习

#### 7.continue break

##### 7.1 continue关键字

**continue关键字**用于立即**跳出本次循环**，**继续下一次循环**（本次循环体中continue之后的代码就会少执行一次)。

##### 7.2 break关键字

break关键字用于立即跳出整个循环（循环结束)。

## 3.JavaScript命名规范以及语法格式

### 1.标识符命名规范

- 变量、函数的命名必须要有意义
- 变量的名称一般用名词
- 函数的名称一般用动词

### 2.操作符规范

```javascript
//操作符的左右两侧各保留一个空格
for (var i = l; i <= 5; i++){
if (i == 3) {
	break; //直接退出整个for循环，跳到整个for循环下面的语句
}
	console.log ('我正在吃第'+ i +'个包子呢');
}
```

## 4.JavaScript 数组

### 1.数组大概念

> 数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。

### 2.创建数组

#### 2.1数组的创建方式

JS中创建数组有两种方式:

- 利用new Array() 创建数组
- 利用数组字面量创建数组

#### 2.2利用new创建数组

```javascript
let arr = [1, 2, 3]
for (let i = 0; i < arr.length; i++) {
    console.log(arr[i])
}
```



```javascript
var 数组名 = new Array();
var arr = new Array () ;//创建一个新的空数组
```

这种方式暂且了解，等学完对象再看注意Array0 ，A要大写

#### 2.3利用数组字面量创建数组

```javascript
//1．使用数组字面量方式创建空的数组
var 数组名 = [] ;
//2．使用数组字面量方式创建带初始值的数组
var 数组名 =['小白'，小黑'，'大黄'，'瑞奇'];
```

- 数组的字面量是方括号[]
- 声明数组并赋值称为数组的初始化
- 这种字面量方式也是我们以后最多使用的方式

#### 2.4数组元素的类型

数组中可以存放任意类型的数据，例字符串，数字，布尔值等。

```javascript
var arrstus = ['小白",12,true,28.9] ;
```

### 3.获取数组元素

#### 3.1数组的索引

索引(下标)∶用来访问数组元素的序号（数组下标从0开始)。

vararr = ['小白','小黑','大黄','瑞奇'];
索引号∶	0		1		2		3

数组可以通过**索引**来访问、设置、修改对应的数组元素，我们可以通过“**数组名[索引**”的形式来获取数组中的元素。
这里的**访问**就是获取得到的意思

```javascript
//定义数组
var arrstus=[1,2,3];
//获取数组中的第2个元素
alert(arrStus[1]);

```

### 4.遍历数组

**遍历**:就是把数组中的每个元素从头到尾都访问一次(类似我们每天早上学生的点名)。

es6语法：

```javascript
Array.forEach(item => {item.value = 1});

Array.every(item=>item.value)==>所有item.value都为true则返回true,否则返回false;

Array.some(item=>item.value)==>存在item.value为true则返回true,否则返回false;

Array.forEach((item, key) => { if (item === '指定元素') arrList.splice(key, 1) })

let newList= Array.filter( (item, index) =>item != '指定元素' )  ==>过滤掉不需要的
```

### 5.数组中新增元素

可以通过修改length长度以及索引号增加数组元素

#### 5.1通过修改length长度新增数组元素

可以通过修改length长度来实现数组扩容的目的

```javascript
length属性是可读写的
var arr = [ 'red','green','blue','pink' ];
arr.length = 7;
console.log(arr);
console.log(arr[ 4]);
console.log(arr[5]);
console.log (arr[6]);
```


其中索引号是4，5，6的空间没有给值，就是声明变量未给值，默认值就是**undefined**。

#### 5.2通过修改数组索引新增数组元素

- 可以通过修改数组索引的方式追加数组元素
- 不能直接给数组名赋值，否则会覆盖掉以前的数据

```
var arr = [ 'red','green','blue','pink'];
arr[4] = 'hotpink';
console.log (arr);
```

这种方式也是我们最常用的一种方式。

### 6.数组排序

冒泡排序︰是一种算法，把一系列的数据按照一定的顺序进行排列显示(从小到大或从大到小)。

**冒泡排序**：是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺字错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢°浮"到数列的顶端。

![Snipaste_2021-02-10_13-40-00](https://s2.loli.net/2022/08/15/PvCoNIBq5T2talj.png)

```javascript
/* 交换躺输为:i=length-1;交换次数为:j=length-i-1  */
let arr = [5, 4, 3, 2, 1];
for (let i = 0; i < arr.length - 1; i++) { // 外层循环管趟数 
    for (let j = 0; j < arr.length - i - 1; j++) { // 里面的循环管 每一趟的交换次数
        // 内部交换2个变量的值 前一个和后面一个数组元素相比较
        if (arr[j] > arr[j + 1]) {
            let temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
```

## 5.JavaScript函数

### 1. 函数的概念 

在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。 虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。 **函数**：就是**封装了一段可被重复调用执行的代码块**。通过此代码块可以实现大量代码的重复使用。

### 2. 函数的使用 

#### 2.1 声明函数 

函数在使用时分为两步：声明函数和调用函数。

```javascript
 // 声明函数 
 function 函数名() { 
 	//函数体代码 
 } 
```

-  function 是声明函数的关键字,必须小写 
-  由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum 

#### 2.2 调用函数 

```javascript
// 调用函数
 函数名(); // 通过调用函数名来执行函数体代码 
```

- 调用的时候千万不要忘记添加小括号 
- 口诀：函数不调用，自己不执行。 

注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。

#### 2.3 函数的封装 

- 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口 
-  简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包） 

### 3. 函数的参数

#### 3.1 形参和实参

在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时， 同样也需要传递相应的参数，这些参数被称为实参。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| 形参 | **形**式上的**参**数 **函数定义**的时候传递的参数 当前并不知道是什么 |
| 实参 | **实**际上的**参**数 **函数调用**的时候传递的参数 实参是传递给形参的 |

**参数的作用** : 在**函数内部**某些值不能固定，我们可以通过参数在**调用函数时传递**不同的值进去。

在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为**形参**，而在调用该函数时，同样也需要传递相应的参数，这些参数被称为**实参**。

```javascript
// 带参数的函数声明 
function 函数名(形参1, 形参2 , 形参3...) {  
// 可以定义任意多的参数，用逗号分隔   
// 函数体 
 } 
 // 带参数的函数调用
 函数名(实参1, 实参2, 实参3...);   
```

#### 3.2 函数参数的传递过程

```javascript
// 声明函数 
function getSum(num1, num2) {   
	console.log(num1 + num2);  
}  
// 调用函数  
getSum(1, 3); // 4 
getSum(6, 5); // 11  
```

1. 调用的时候实参值是传递给形参的
2. 形参简单理解为：**不用声明的变量**
3. 实参和形参的多个参数之间用逗号（,）分隔

#### 3.3 函数形参和实参个数不匹配问题

| 参数个数             | 说明                               |
| -------------------- | ---------------------------------- |
| 实参个数等于形参个数 | 输出正确结果                       |
| 实参个数大于形参个数 | 只取到形参的个数                   |
| 实参个数小于形参个数 | 多的形参定义为undefined，结果为NaN |

```javascript
function sum(num1, num2) {   
	console.log(num1 + num2);  
}  
sum(100, 200);        // 形参和实参个数相等，输出正确结果 sum(100,  400, 500, 700);  // 实参个数多于形参，只取到形参的个数  
sum(200);         // 实参个数少于形参，多的形参定义为undefined，结果为NaN  
```

#### 3.4 小结

- 函数可以带参数也可以不带参数
- 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined
- 调用函数的时候，函数名括号里面的是实参
- 多个参数中间用逗号分隔
- 形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配

### 4.函数的返回值

#### 4.1 return 语句

有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。

return 语句的语法格式如下：

```javascript
// 声明函数 
function 函数名（）{  ... return 需要返回的值;} 
// 调用函数
函数名();  
// 此时调用函数就可以得到函数体内return 后面的值  
```

- 在使用 return 语句时，函数会停止执行，并返回指定的值
-  如果函数**没有 return** ，返回的值是 **undefined**

有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。

例如，声明了一个sum()函数，该函数的返回值为666，其代码如下：

```javascript
// 声明函数                         
function sum（）{   ...    return 666;}  
// 调用函数 
sum(); // 此时 sum 的值就等于666，因为 return  语句会把自身后面的值返回给调用者   
```

#### 4.2 return 终止函数

return 语句之后的代码不被执行。

```javascript
function add(num1，num2){   //函数体
  return num1 + num2; // 注意：return 后的代码不执行   
    alert('我不会被执行，因为前面有 return');
}
var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值
alert(resNum);     // 27
```

#### 4.3 return 的返回值 

return 只能返回一个值。如果用逗号隔开多个值，以最后一个为准。

```javascript
function  add(num1，num2){      
    //函数体   
    return num1，num2;  
}  
var resNum =  add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值  alert(resNum);     // 6  
```

#### 4.4 函数没有 return 返回 undefined

函数都是有返回值的

1. 如果有return 则返回 return 后面的值

2. 如果没有return 则返回 undefined 

#### 4.5 break ,continue ,return 的区别

- break ：结束当前的循环体（如 for、while） 
- continue ：跳出本次循环，继续执行下次循环（如 for、while）
- return ：结束函数 不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码

### 5. arguments的使用

当我们不确定有多少个参数传递的时候，可以用 **arguments** 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个**内置对象**。所有函数都内置了一个 arguments 对象，arguments 对象中存**储了传递的所有实参**。

**arguments展示形式是一个伪数组**，因此可以进行遍历。伪数组具有以下特点：

- 具有 length 属性
- 按索引方式储存数据
- 不具有数组的 push , pop 等方法

### 6.函数的两种声明方式

#### 1.自定义函数方式(命名函数) 

利用函数关键字 function 自定义函数方式。

```javascript
// 声明定义方式  
function  fn() {...}  
// 调用 
fn();    
```

- 因为有名字，所以也被称为**命名函数**
- 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面

#### 2.函数表达式方式(匿名函数）

利用函数表达式方式的写法如下： 

```javascript
// 这是函数表达式写法，匿名函数后面跟分号结束 
var fn = function(){...}；
// 调用的方式，函数调用必须写到函数体下面
fn();
```

- 因为函数没有名字，所以也被称为匿名函数
- 这个fn 里面存储的是一个函数 
- 函数表达式方式原理跟声明变量方式是一致的
- 函数调用的代码必须写到函数体后面

## 6.JavaScript 作用域

### 1.作用域

#### 1.1作用域概述

通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

### 2.变量的作用域

#### 2.1变量作用域的分类

在JavaScript中，根据作用域的不同，变量可以分为两种:

- 全局变量
- 局部变量

#### 2.2全局变量

在全局作用域下声明的变量叫做全局变量(在函数外部定义的变量)。.

- 全局变量在代码的任何位置都可以使用
- 在全局作用域下var声明的变量是全局变量
- 特殊情况下，在函数内不使用var声明的变量也是全局变量(不建议使用)

#### 2.3局部变量

在局部作用域下声明的变量叫做局部变量(在函数内部定义的变量)

- 局部变量只能在该函数内部使用
- 在函数内部var 声明的变量是局部变量
- 函数的**形参**实际上就是局部变量

#### 2.3全局变量和局部变量的区别

- 全局变量:在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存
- 局部变量︰只在函数内部使用，当其所在的代码块被执行时，会被初始化;当代码块运行结束后，就会被销毁，因此更节省内存空间

### 3.作用域链

- 只要是代码，就至少有一个作用域
- 写在函数内部的局部作用域
- 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域
- 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链

## 7.JavaScript 预解析

### 1.预解析

JavaScript代码是由浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行JavaScript代码的时候分为两步∶预解析和代码执行。

1. 我们js引擎运行js 分为两步：预解析代码执行
   - 预解析 js引擎会把js 里面所有的 var 还有 function 提升到当前作用域的最前面
   - 代码执行 按照代码书写的顺序从上往下执行

2. 预解析分为 变量预解析（变量提升）和 函数预解析（函数提升）
   - 变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作
   - 函数提升 就是把所有的函数声明提升到当前作用域的最前面 不调用函数

## 8.JavaScript对象

### 1.对象

#### 1.1什么是对象?

在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。

对象是由属性和方法组成的。

- 属性∶事物的**特征**，在对象中用**属性**来表示(常用名词)
- 方法︰事物的**行为**，在对象中用**方法**来表示(常用动词)

#### 1.2为什么需要对象

保存一个值时，可以使用**变量**，保存多个值(一组值)时，可以使用**数组**。如果要保存一个人的完整信例如，将“张三疯”的个人的信息保存在数组中的方式为︰

```javascript
var arr =[ '张三疯，'男'，128,154] ;
```

JS中的对象表达结构更清晰，更强大。张三疯的个人信息在对象中的表达结构如下∶

```javascript
张三疯.姓名='张三疯';
张三疯.性别='男';
张三疯.年龄= 128;
张三疯.身高= 154 ;
```

```javascript
person.name ='张三疯';//或者person['name']='张三疯'
person.sex ='男';
person.age = 128;
person.height = 154;
```

```javascript
//删除指定元素
delete Object[key]
```

### 2.创建对象的三种方式

在JavaScript中，现阶段我们可以采用三种方式创建对象( object ) :

- 利用**字面量**创建对象

- 利用**new Object**创建对象
- 利用**构造函数**创建对象 

#### 2.1利用字面量创建对象

对象字面量:就是花括号{}里面包含了表达这个具体事物（对象）的属性和方法。

**变量、属性、函数、方法总结**

- 变量:单独声明赋值，单独存在
- 属性:对象里面的变量称为属性，不需要声明，用来描述该对象的特征
- 函数︰单独存在的，通过“函数名()”的方式就可以调用
- 方法∶对象里面的函数称为方法，方法不需要声明，使用“对象.方法名(”的方式就可以调用，方法用来描述该对象的行为和功能。

#### 2.2利用new Object创建对象

跟我们前面学的new Array)原理一致

#### 2.3 利用构造函数创建对象

**构造函数** ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起 使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 

在 js 中，使用构造函数要时要注意以下两点： 

- 构造函数用于创建某一类对象，其**首字母要大写** 
- 构造函数要**和 new 一起使用**才有意义

```javascript
function Star(uname, age, sex) {
    this.name = uname;
    this.age = age;
    this.sex = sex;
    this.sing = function (sang) {
        console.log(sang);
    }
}
var ldh = new Star('刘德华', 18, '男'); // 调用函数返回的是一个对象
```

注意 

1. 构造函数约定首字母大写。 

2. 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。 
3. 构造函数中不需要 return 返回结果。 
4. 当我们创建对象的时候，必须用 new 来调用构造函数。

#### 2.4 构造函数和对象

- 构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class） 
- 创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化

### 3.new关键字

new在执行时会做四件事情:

1. 在内存中创建一个新的空对象。

2. 让 this指向这个新的对象。

3. 执行构造函数里面的代码，给这个新对象添加属性和方法。

4. 返回这个新对象（所以构造函数里面不需要return ) 。

### 4. 遍历对象属性

for...in 语句用于对数组或者对象的属性进行循环操作。 其语法如下： 

```javascript
for (变量 in 对象名字) { 
	// 在此执行代码 
} 
```

语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。 

```javascript
for (var k in obj) { 
    console.log(k); // 这里的 k 是属性名 
    console.log(obj[k]); // 这里的 obj[k] 是属性值 
}
```

**小结**

1. 对象可以让代码结构更清晰 
2. 对象 object 复杂数据类型。 
3. 本质：对象就是一组无序的相关属性和方法的集合。 
4. 构造函数泛指某一大类，比如苹果，不管是红色苹果还是绿色苹果，都统称为苹果。 
5. 对象实例特指一个事物，比如这个苹果、正在给你们讲课的pink老师等。 
6. for...in 语句用于对对象的属性进行循环操作。

## 9.JavaScript内置对象

### 1.内置对象

- 
  JavaScript中的对象分为3种:自定义对象、内置对象、浏览器对象
- 前面两种对象是JS基础内容，属于ECMAScript;第三个浏览器对象属于我们S独有的，我们JS API讲解
- 内置对象就是指JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法)
- 内置对象最大的优点就是帮助我们快速开发
- JavaScript提供了多个内置对象:Math、 Date . Array、string等

```javascript
//去除两边空格
trim()
//切割字符串
slice()
let str='index.js';	console.log(str.slice(-3)))==>'.js'
```

### 2. 查文档 

#### 2.1 MDN

学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C 来查询。 

Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。 

MDN: https://developer.mozilla.org/zh-CN/

#### 2.2 如何学习对象中的方法

1. 查阅该方法的功能 

2. 查看里面参数的意义和类型 
3. 查看返回值的意义和类型 
4. 通过 demo 进行测试

### 3. Math 对象 

#### 3.1 Math 概述

Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值 等）可以使用 Math 中的成员。

```javascript
Math.PI // 圆周率
Math.floor() // 向下取整
Math.ceil() // 向上取整
Math.round() // 四舍五入版 就近取整 注意 -3.5 结果是 -3
Math.abs() // 绝对值
Math.max()/Math.min() // 求最大和最小值
```

**注意：上面的方法必须带括号**

#### 3.2 随机数方法 random()

random() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 <= x < 1 得到一个两数之间的随机整数，包括两个数在内

```javascript
function getRandom(min, max) {
 return Math.floor(Math.random() * (max - min + 1)) + min;
}
```

生成length个0~9的随机数:

```javascript
function random(length) {
    let result = ''
    for (let i = 0; i < length; i++) {
        let index = Math.floor(Math.random() * 10)
        result += index
    }
    return result
}
```

### 4. 日期对象 

#### 4.1 Date 概述

- Date 对象和 Math 对象不一样，他是一个构造函数，所以我们需要实例化后才能使用 
- Date 实例用来处理日期和时间

#### 4.2 Date()方法的使用

**1.获取当前时间必须实例化**

```javascript
var now = new Date ();
console.log (now) ;
```

**2.Date(构造函数的参数**
如果括号里面有时间，就返回参数里面的时间。例如日期格式字符串为‘2019-5-1’，可以写成new Date(2019-5-1")或者new Date(2019/5/1)

#### 4.3 日期格式化

| 方法名        | 说明                     | 代码               |
| ------------- | ------------------------ | ------------------ |
| getFullYear() | 获取当年                 | dObj.getFullYear() |
| getMonth()    | 获取当月(0-11)           | dObj.getMonth()    |
| getDate()     | 获取当天日期             | dObj.getDate()     |
| getDay()      | 获取星期几(周日0到周六6) | dobj.getDay()      |
| getHours()    | 获取当前小时             | dobj.getHours()    |
| getMinutes()  | 获取当前分钟             | dObj.getMinutes()  |
| getSeconds()  | 获取当前秒钟             | dObj.getSeconds()  |

#### 4.4 获取日期的总的毫秒形式 (时间戳)

Date 对象是基于1970年1月1日（世界标准时间）起的毫秒数 

为什么计算机起始时间从1970年开始? 我们经常利用总的毫秒数来计算时间，因为它更精确

```javascript
// 实例化Date对象 
var now = new Date();
// 1. 用于获取对象的原始值 
console.log(date.valueOf()) 
console.log(date.getTime()) 
// 2. 简单写可以这么做 
var now = + new Date(); 
// 3. HTML5中提供的方法，有兼容性问题 
var now = Date.now(); 
```

**小结代码：**

```javascript
/* 生成系统当前时间 */
function createTime() {
    const date = new Date()//创建时间对象
    const yy = date.getFullYear()//年
    const MM = (date.getMonth() + 1 + '').padStart(2, '0')//月(padStart:字符串不满2位数,开头补全'0')
    const dd = (date.getDate() + '').padStart(2, '0')//日
    const hh = (date.getHours() + '').padStart(2, '0')//小时
    const mm = (date.getMinutes() + '').padStart(2, '0')//分钟
    const ss = (date.getSeconds() + '').padStart(2, '0')//秒钟
    return `${yy}-${MM}-${dd} ${hh}:${mm}:${ss}`//返回时间
}
/* 转换时间戳 */
function getTimes(time) {
    const date = +new Date(time)
    // const date1 = Date.now()//H5当前时间戳
    // console.log(date1)
    return date
}
/* 格式化时间 */
function formatTime(time) {
    /* 格式化的时间戳必须是Number型*/
    const date = new Date(time)//创建时间对象
    const yy = date.getFullYear()//年
    const MM = (date.getMonth() + 1 + '').padStart(2, '0')//月
    const dd = (date.getDate() + '').padStart(2, '0')//日
    const hh = (date.getHours() + '').padStart(2, '0')//小时
    const mm = (date.getMinutes() + '').padStart(2, '0')//分钟
    const ss = (date.getSeconds() + '').padStart(2, '0')//秒钟
    return `${yy}-${MM}-${dd} ${hh}:${mm}:${ss}`//返回时间
}
/* 倒计时 */
function countDown(time) {
    var nowTime = +new Date(); // 当前时间戳
    var endTime = +new Date(time); // 结束时间戳
    var times = (endTime - nowTime) / 1000; // 剩余时间总的秒数 
    var dd = parseInt(times / 60 / 60 / 24).toString().padStart(2, '0'); // 天
    var hh = parseInt(times / 60 / 60 % 24 + '').toString().padStart(2, '0'); //时
    var mm = parseInt(times / 60 % 60 + '').toString().padStart(2, '0'); // 分
    var ss = parseInt(times % 60 + '').toString().padStart(2, '0'); // 当前的秒
    return `${dd}天${hh}时${mm}分${ss}秒`//返回时间
}
console.log('系统当前时间:', createTime())
console.log('时间戳:', getTimes(createTime()))
console.log('转换时间戳:', getTimes('2021-03-01 08:00:00'))
console.log('格式化指定时间:', formatTime(getTimes('2021-03-01 08:00:00')))
console.log('格式化当前时间:', formatTime(getTimes(createTime())))
console.log('倒计时:', countDown('2021-02-13 08:00:00'))
```

### 5. 数组对象

#### 5.1 数组对象的创建	

创建数组对象的两种方式 

- 字面量方式 
- new Array()

#### 5.2 检测是否为数组

-  instanceof 运算符，可以判断一个对象是否属于某种类型 
- Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法

```javascript
var arr = [1, 23];
var obj = {};
console.log(arr instanceof Array); // true
console.log(obj instanceof Array); // false
console.log(Array.isArray(arr)); // true
console.log(Array.isArray(obj)); // false
```

#### 5.3 添加删除数组元素的方法

| 方法名            | 说明                                                  | 返回值               |
| ----------------- | ----------------------------------------------------- | -------------------- |
| push(参数1....)   | 末尾添加一个或多个元素，注意修改原数组                | 并返回新的长度       |
| pop()             | 删除数组最后一个元素，把数组长度减1无参数、修改原数组 | 返回它删除的元素的值 |
| unshift(参数1...) | 向数组的开头添加一个或更多元素，注意修改原数组        | 并返回新的长度       |
| shift()           | 删除数组的第一个元素，数组长度减1无参数、修改原数组   | 返回它删除的元素的值 |
| splice(index,num) | 删除指定元素：index第几个开始，num为删除个数          | 返回它删除的元素的值 |

#### 5.4 数组排序

| 方法名    | 说明                        | 是否修改原数组                   |
| --------- | --------------------------- | -------------------------------- |
| reverse() | 颠倒数组中元素的顺序,无参数 | 该方法会改变原来的数组返回新数组 |
| sort()    | 对数组的元素进行排序        | 该方法会改变原来的数组返回新数组 |

```javascript
var arr = [1, 64, 9, 6];
arr.sort(function(a, b) {
 return b - a; // 降a序
 // return a - b; // 升序
});
console.log(arr);
```

#### 5.5 数组索引方法

| 方法名        | 说明                           | 返回值                                   |
| ------------- | ------------------------------ | ---------------------------------------- |
| indexOf()     | 数组中查找给定元素的第一个索引 | 如果存在返回索引号如果不存在，则返回-1。 |
| lastIndexOf() | 在数组中的最后一个的索引,      | 如果存在返回索引号如果不存在，则返回-1。 |

**封装数组去重复**

```javascript
// 封装一个 去重的函数 unique 独一无二的 
function unique(arr) {
    let newArr = [];
    for (let i = 0; i < arr.length; i++) {
        if (newArr.indexOf(arr[i]) === -1) {
            newArr.push(arr[i]);
        }
    }
    return newArr;
}
```

#### 5.6 数组转换为字符串

| 方法名         | 说明                                         | 返回值         |
| -------------- | -------------------------------------------- | -------------- |
| toString()     | 把数组转换成字符串，逗号分隔每一项           | 返回一个字符串 |
| join("分隔符') | 方法用于把数组中的所有元素转换为一个字符串。 | 返回一个字符串 |

#### 5.7 其他方法

| 方法名   | 说明                                                       | 返回值                                 |
| -------- | ---------------------------------------------------------- | -------------------------------------- |
| concat() | 连接两个或多个数组不影响原数组                             | 返回一个新的数组                       |
| slice()  | 数组截取slice(begin, end),包括 begin不包括end,不影响原数组 | 返回被截取项目的新数组                 |
| splice() | 数组删除splice(第几个开始,要删除个数)                      | 返回它删除的元素的值，这个会影响原数组 |

slice() 和 splice() 目的基本相同，建议同学们重点看下 splice()

###  6.字符串对象

####  6.1基本包装类型

为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。 基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。

```javascript
// 下面代码有什么问题？
var str = 'andy';
console.log(str.length);
```

按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 js 会把 基本数据类型包装为复杂数据类型，其执行过程如下 ：

```javascript
// 1. 生成临时变量，把简单类型包装为复杂数据类型
var temp = new String('andy');
// 2. 赋值给我们声明的字符变量
str = temp;
// 3. 销毁临时变量
temp = null;
```

#### 6.2字符串的不可变

指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。

```javascript
var str = 'abc';
str = 'hello';
// 当重新给 str 赋值的时候，常量'abc'不会被修改，依然在内存中
// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变
// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题
var str = '';
for (var i = 0; i < 100000; i++) {
 str += i;
}
console.log(str); // 这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间
```

#### 6.3根据字符返回位

字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串。

| 方法名                               | 说明                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| indexOf('要查找的字符，[开始的位置]) | 返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是index索引号 |
| lastIndexOf()                        | 从后往前找，只找第一个匹配的                                 |

#### 6.4根据位置返回字符（重点）

| 方法名            | 说明                                     | 使用                          |
| ----------------- | ---------------------------------------- | ----------------------------- |
| charAt(index)     | 返回指定位置的字符(index字符串的索引号)  | str.charAt(O)                 |
| charCodeAt(index) | 获取指定位置处字符的ASCII码(index索引号) | str.charCodeAt(O)             |
| str[index]        | 获取指定位置处字符                       | HTML5，IE8+支持和charAt()等效 |

#### 6.5字符串操作方法（重点）

| 方法名                    | 说明                                                         | 返回值                       |
| ------------------------- | ------------------------------------------------------------ | ---------------------------- |
| concat(str1,str2,str3...) | 用于连接两个或多个字符串。拼接字符串，等效于+，+更常用       | 返回新字符串                 |
| substr(start,length)      | 从start位置开始, length 取的个数重点记住这个                 | 返回截取部分，不影响原字符串 |
| slice(start, end)         | 从start位置开始，截取到end位置，end取不到(他们俩都是索引号） | 返回截取部分，不影响原字符串 |
| substring(start, end)     | 基本和slice相同，但是不接受负值                              | 返回截取部分，不影响原字符串 |

#### 6.6replace()方法

replace() 方法用于在字符串中用一些字符替换另一些字符。 其使用格式如下：

```javascript
 replace(被替换的字符串， 要替换为的字符串);//只替换第一个相同的字符
```

#### 6.7split()方法

split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。 例如下面代码： 

```javascript
var str = 'a,b,c,d';
console.log(str.split(',')); // 返回的是一个数组 [a, b, c, d]
```

#### 6.8其他方法

- toUpperCase() //转换大写 
- toLowerCase() //转换小写

示例：

```javascript
let str8 = 'chenzhifeng'
let str9 = str8.toUpperCase()//转换为大写
let str10 = str9.toLowerCase()//转换为小写
console.log(str8, str9, str10)
```

## 10.JavaScript简单类型与复杂类型

### 1.简单类型与复杂类型

简单类型又叫做基本数据类型或者**值类型**，复杂类型又叫做**引用类型**。 

- 值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型 string ，number，boolean，undefined，null 
- 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型 通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等

### 2.堆和栈

堆栈空间分配区别： 　

1. 栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；

    **简单数据类型存放到栈里面** 　

2. 堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。 

   **复杂数据类型存放到堆里面**

**注意**：JavaScript中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言。

### 3.简单类型的内存分配

- 值类型（简单数据类型）： string ，number，boolean，undefined，null 
- 值类型变量的数据直接存放在变量（栈空间）中

### 4. 复杂类型的内存分配

- 引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等 
- 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中

### 5.简单类型传参

函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈 空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。

```javascript
function fn(a) {
 a++;
 console.log(a);
}
var x = 10;
fn(x);
console.log(x);
```

### 6. 复杂类型传参

函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地 址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。

```javascript
function Person(name) {
 this.name = name;
}
function f1(x) { // x = p
 console.log(x.name); // 2. 这个输出什么 ?
 x.name = "张学友";
 console.log(x.name); // 3. 这个输出什么 ?
}
var p = new Person("刘德华");
console.log(p.name); // 1. 这个输出什么 ?
f1(p);
console.log(p.name); // 4. 这个输出什么 ? 
```

# 二.Web APls简介

## 1.js基础与Web API关联

**JS基础阶段**

- 我们学习的是ECMAscript标准规定的基本语法
- 要求同学们掌握Js基础语法
- 只学习基本语法，做不了常用的网页交互效果
- 目的是为了Js后面的课程打基础、做铺垫

**Web APls阶段**

- web APIs是w3c组织的标准

- web APIs 我们主要学习DOM和BOM
- web APIs是我们Js 所独有的部分
- 我们膝要学习页面交互功能
- 需要使用Js基础的课程内容做基础

Js基础学习ECMAScript基础语法为后面作铺垫，web APIs是Js 的应用，大量使用Js基础语法做交互效果

## 2.API和Web API

### 2.1 API

APl (Application Programming Interface,应用程序编程接口)是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。
简单理解︰API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。

### 2.2 Web API

Web API是浏览器提供的一套操作浏览器功能和页面元素的API( BOM和DOM)。

现阶段我们主要针对于浏览器讲解常用的API，主要针对浏览器做交互效果。

比如我们想要浏览器弹出一个警示框，直接使用alert(‘弹出’)

MDN详细API : https://developer.mozilla.org/zh-CN/docs/Web/API

因为Web API很多，所以我们将这个阶段称为Web APls

### 2.3 API和Web API总结

1. API是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现
2. Web API主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。
3. Web API一般都有输入和输出（函数的传参和返回值)，WebAPI很多都是方法（函数)
4. 学习Web API可以结合前面学习内置对象方法的思路学习

## 3.DOM

### 1.DOM简介

#### 1.什么是 DOM

文档对象模型( Document Object Model，简称DOM ）)，是W3C组织推荐的处理可扩展标记语言（HTML或者XML)的标准**编程接口**。
W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。

#### 2.DOM 树

![image-20210213133249765](https://s2.loli.net/2022/08/15/xnSNlQFPk4BLJeu.png)

- 文档:一个页面就是一个文档，DOM中使用document表示
- 元素︰页面中的所有标签都是元素，DOM中使用element表示
- 节点∶网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示

**DOM把以上内容都看做是对象**

### 2. 获取元素

#### 2.1 如何获取页面元素

DOM在我们实际开发中主要用来操作元素。 

我们如何来获取页面中的元素呢? 

获取页面中的元素可以使用以下几种方式:

- 根据ID获取根据标签名获取
- 通过HTML5新增的方法获取
- 特殊元素获取

#### 2.2 根据 ID 获取

使用 getElementById() 方法可以获取带有 ID 的元素对象。

```javascript
document.getElementById('id');
```

使用 **console.dir()** 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。

#### 2.3 根据标签名获取

使用getElementsByTagName()方法可以返回带有指定标签名的对象的集合。

```javascript
document.getElementsByTagName ( '标签名');
```

**注意**:

1. 因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。
2. 得到元素对象是动态的

#### 2.4 通过 HTML5 新增的方法获取

```
1. document.getElementsByClassName ('类名');//根据类名返回元素对象集合
2. document.queryselector('选择器') ;//根据指定选择器返回第一个元素对象
3. document.queryselectorAl1('选择器');//根据指定选择器返回
```

   **注意**： querySelector 和 querySelectorAll里面的选择器需要加**符号**,比如:document.querySelector('#nav');

#### 2.5获取特殊元素(body,html)

获取body元素

```javascript
doucumnet.bodyl/返回body元素对象
```

获取html元素

```javascript
document.documentElement l/返回html元素对象
```

### 3. 事件基础

#### 3.1 事件概述

JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。 **简单理解**： 触发--- 响应机制。 

网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。

#### 3.2事件三要素

1. 事件源 （谁） 
2. 事件类型 （什么事件）
3. 事件处理程序 （做啥）

#### 3.3执行事件的步骤

1. 获取事件源
2. 注册事件（绑定事件)
3. 添加事件处理程序(采取函数赋值形式)

#### 3.4常见的鼠标事件(略)

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

#### 3.5 分析事件三要素

- 下拉菜单三要素 
- 关闭广告三要素

### 4.操作元素

JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内 容 、属性等。注意以下都是属性

#### 4.1 改变元素内容

```
element.innerText
```

从起始位置到终止位置的内容,但它去除 html标签，同时空格和换行也会去掉

```
element.innerHTML
```

起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行

#### 4.2 常用元素的属性操作

```
1. innerText、innerHTML 改变元素内容
2. src、href
3. id、alt、title
```

#### 4.3 表单元素的属性操作

利用 DOM 可以操作如下表单元素的属性：

```
type、value、checked、selected、disabled
```

#### 4.4 样式属性操作

我们可以通过 JS 修改元素的大小、颜色、位置等样式。

```
1. element.style 行内样式操作
2. element.className 类名样式操作
```

**注意**： 

1. JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor 

2. JS 修改 style 样式操作，产生的是行内样式，CSS 权重比较高
3. 如果样式修改较多，可以采取操作类名方式更改元素样式。 
4. class因为是个保留字，因此使用className来操作元素类名属性 
5. className 会直接更改元素的类名，会覆盖原先的类名。

**操作元素总结**

操作元素是 DOM 核心内容

![image-20210213143412945](https://s2.loli.net/2022/08/15/WNbw57i9yldDKfB.png)

#### 4.5 排他思想

如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法： 

1. 所有元素全部清除样式（干掉其他人） 
2. 给当前元素设置样式 （留下我自己） 
3. 注意顺序不能颠倒，首先干掉其他人，再设置自己

#### 4.6 自定义属性的操作

1. 获取属性值 

- element.属性 获取属性值。 
- element.getAttribute('属性');

**区别：** 

- element.属性 获取内置属性值（元素本身自带的属性） 
- element.getAttribute(‘属性’); 主要获得自定义的属性 （标准） 我们程序员自定义的属性

2. 设置属性值 

- element.属性 = ‘值’ 设置内置属性值。 
- element.setAttribute('属性', '值'); 

**区别：** 

- element.属性 设置内置属性值
- element.setAttribute(‘属性’); 主要设置自定义的属性 （标准）

3. 移除属性 

- element.removeAttribute('属性');

#### 4.7 H5自定义属性

自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。 

自定义属性获取是通过getAttribute(‘属性’) 获取。 

但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。 

H5给我们新增了自定义属性：

**1. 设置H5自定义属性** 

H5规定自定义属性data-开头做为属性名并且赋值。

 比如 `<div data-index=“1”></div>`

或者使用 JS 设置 element.setAttribute(‘data-index’, 2)

**2.获取H5自定义属性**

1. 兼容性获取 element.getAttribute(‘data-index’);
2. H5新增 element.dataset.index 或者 element.dataset[‘index’]    ie 11才开始支持

### 5. 节点操作

#### 5.1 为什么学节点操作

获取元素通常使用两种方式：

**1.利用DOM提供的方法获取元素**

- document.getElementByld()
- document.getElementsByTagName()
- document.querySelector等
- 逻辑性不强、繁琐

**2.利用节点层级关系获取元素**

- 利用父子兄节点关系获取元素
- 逻辑性强，但是兼容性稍差

这两种方式都可以获取元素节点，我们后面都会使用，但是节点操作更简单

#### 5.2 节点概述

网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。 HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以 创建或删除。

![image-20210213133249765](https://s2.loli.net/2022/08/15/xnSNlQFPk4BLJeu.png)

一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个 基本属性。 

- 元素节点 nodeType 为 1 
- 属性节点 nodeType 为 2 
- 文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等） 

我们在实际开发中，节点操作主要操作的是元素节点

#### 5.3 节点层级

利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。

![image-20210213133249765](https://s2.loli.net/2022/08/15/xnSNlQFPk4BLJeu.png)

利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。 

**1.父级节点** 

```
node.parentNode
```

- parentNode 属性可返回某节点的父节点，注意是最近的一个父节点 
- 如果指定的节点没有父节点则返回 null 

**2.子节点**

```
1. parentNode.childNodes（标准） 
```

parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合。

注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等。 

如果只想要获得里面的元素节点，则需要专门处理。 所以我们一般不提倡使用childNodes

```javascript
var ul = document.querySelector(‘ul’);
for (var i = 0; i < ul.childNodes.length; i++) {
    if (ul.childNodes[i].nodeType == 1) {
        // ul.childNodes[i] 是元素节点
        console.log(ul.childNodes[i]);
    }
}
```

```
2. parentNode.children（非标准）
```

parentNode.children 是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返 回 （**这个是我们重点掌握的**）。 虽然children 是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用

```
3. parentNode.firstChild
```

返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。 

```
4.parentNode.lastChild
```

返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。

```
5. parentNode.firstElementChild
```

返回第一个子元素节点，找不到则返回null。 

```
6. parentNode.lastElementChild
```

返回最后一个子元素节点，找不到则返回null。 

**注意**：这两个方法有兼容性问题，IE9 以上才支持。

实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？ 

解决方案： 

1. 如果想要第一个子元素节点，可以使用 parentNode.chilren[0] 
2. 如果想要最后一个子元素节点，可以使用 parentNode.chilren[parentNode.chilren.length - 1] 

 **3. 兄弟节点**

```
1. node.nextSibling
```

返回当前元素的下一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。 

```
2. node.previousSibling 
```

返回当前元素上一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。

```
3. node.nextElementSibling 
```

返回当前元素下一个兄弟元素节点，找不到则返回null。 

```
4. node.previousElementSibling 
```

返回当前元素上一个兄弟节点，找不到则返回null。 

**注意**：这两个方法有兼容性问题， IE9 以上才支持。

**自己封装一个兼容性的函数** 

```javascript
function getNextElementSibling(element) {
    var el = element;
    while (el = el.nextSibling) {
        if (el.nodeType === 1) {
            return el;
        }
    }
    return null;
} 
```

#### 5.4 创建节点

```
document.createElement('tagName') 
```

document.createElement() 方法创建由 tagName 指定的 HTML 元素。因为这些元素原先不存在， 是根据我们的需求动态生成的，所以我们也称为**动态创建元素节点**。

####  5.5添加节点

```
1. node.appendChild(child) 
```

node.appendChild() 方法将一个节点添加到指定父节点的子节点列表**末尾**。类似于 CSS 里面的 after 伪元素。 

```
2. node.insertBefore(child, 指定元素) 
```

node.insertBefore() 方法将一个节点添加到父节点的指定子节点**前面**。类似于 CSS 里面的 before 伪元素。

#### 5.6 删除节点

```
node.removeChild(child)
```

 node.removeChild() 方法从 DOM 中删除一个子节点，返回删除的节点。

#### 5.7 复制节点(克隆节点)

```
node.cloneNode() 
```

node.cloneNode() 方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点 

**注意**： 

1. 如果括号参数为空或者为 false ，则是**浅拷贝**，即只克隆复制节点本身，不克隆里面的子节点。 
2. 如果括号参数为 true ，则是**深度拷贝**，会复制节点本身以及里面所有的子节点。

#### 5.8 三种动态创建元素区别

- document.write() 
- element.innerHTML
- document.createElement() 

**区别** 

1.  document.write 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘 
2.  innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘 

3. innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂 
4.  createElement() 创建多个元素效率稍低一点点，但是结构更清晰 

**总结**：不同浏览器下，innerHTML 效率要比 creatElement 高

### 6. DOM 重点核心

文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言 （HTML或者XML）的标准编程接口。 

W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。 

1. 对于JavaScript，为了能够使JavaScript操作HTML，JavaScript就有了一套自己的dom编程接口。 
2. 对于HTML，dom使得html形成一棵dom树. 包含 文档、元素、节点

我们获取过来的DOM元素是 一个对象（object），所以称 为 文档对象模型

关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。

#### 6.1 创建

1. document.write 
2. innerHTML 
3. createElement

#### 6.2 增

1. appendChild 

2. insertBefore

#### 6.3 删

1. removeChild

#### 6.4 改

主要修改dom的元素属性，dom元素的内容、属性, 表单的值等

1. 修改元素属性： src、href、title等 

2. 修改普通元素内容： innerHTML 、innerText 
3. 修改表单元素： value、type、disabled等 
4. 修改元素样式： style、className

#### 6.5 查

主要获取查询dom的元素

1. DOM提供的API 方法： getElementById、getElementsByTagName 古老用法 不太推荐
2. H5提供的新方法： querySelector、querySelectorAll 提倡
3. 利用节点操作获取元素： 父(parentNode)、子(children)、兄(previousElementSibling、 nextElementSibling) 提倡

#### 6.6 属性操作

主要针对于自定义属性。

1. setAttribute：设置dom的属性值
2. getAttribute：得到dom的属性值
3. removeAttribute移除属性

#### 6.7 事件操作

给元素注册事件， 采取 事件源.事件类型 = 事件处理程序

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

## 4.事件高级

### 1. 注册事件（绑定事件）

#### 1.1注册事件概述

给元素添加事件，称为注册事件或者绑定事件。
注册事件有两种方式:传统方式和方法监听注册方式

**传统注册方式**

- 利用on开头的事件onclick
- `<button onclick="alert('hi~')"></button>`
- btn.onclick = function() {}

- 特点:注册事件的唯一性

- 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数

**方法监听注册方式**

- w3c标准推荐方式
- addEventListener()它是一个方法
- IE9之前的E不支持此方法，可使用attachEvent()代替
- 特点:同一个元素同一个事件可以注册多个监听器
- 按注册顺序依次执行

#### 1.2 addEventListener 事件监听方式

```
 eventTarget.addEventListener(type, listener[, useCapture]) 
```

eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对 象触发指定的事件时，就会执行事件处理函数。 

该方法接收三个参数： 

- type：事件类型字符串，比如 click 、mouseover ，注意这里不要带 on 
- listener：事件处理函数，事件发生时，会调用该监听函数 
- useCapture：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习

#### 1.3 attachEvent 事件监听方式

```
 eventTarget.attachEvent(eventNameWithOn, callback) 
```

eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触 发指定的事件时，指定的回调函数就会被执行。 

该方法接收两个参数：

- eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on 
- callback： 事件处理函数，当目标触发事件时回调函数被调用 

注意：IE8 及早期版本支持

#### 1.4 注册事件兼容性解决方案

```javascript
function addEventListener(element, eventName, fn) {
    // 判断当前浏览器是否支持 addEventListener 方法
    if (element.addEventListener) {
        element.addEventListener(eventName, fn); // 第三个参数 默认是false
    } else if (element.attachEvent) {
        element.attachEvent('on' + eventName, fn);
    } else {
        // 相当于 element.onclick = fn;
        element['on' + eventName] = fn;
    }
}
```

**兼容性处理的原则： 首先照顾大多数浏览器，再处理特殊浏览器**

### 2. 删除事件（解绑事件）

#### 2.1 删除事件的方式

1. 传统注册方式

```
eventTarget.onclick = null;
```

2. 方法监听注册方式

```
① eventTarget.removeEventListener(type, listener[, useCapture]);
② eventTarget.detachEvent(eventNameWithOn, callback);
```

#### 2.2 删除事件兼容性解决方案

```javascript
function removeEventListener(element, eventName, fn) {
    // 判断当前浏览器是否支持 removeEventListener 方法
    if (element.removeEventListener) {
        element.removeEventListener(eventName, fn); // 第三个参数 默认是false
    } else if (element.detachEvent) {
        element.detachEvent('on' + eventName, fn);
    } else {
        element['on' + eventName] = null;
    }
}
```

### 3. DOM 事件流

事件流描述的是从页面中接收事件的顺序。 

**事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流**。 比如我们给一个div 注册了点击事件：

DOM 事件流分为3个阶段： 

1. 捕获阶段 
2. 当前目标阶段 
3. 冒泡阶段

- 事件冒泡： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。 
- 事件捕获： 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。

我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具 体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过 程相当于事件冒泡。

注意 

1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。 
2. onclick 和 attachEvent 只能得到冒泡阶段。
3. addEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕 获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理 程序。 
4. 实际开发中我们很少使用事件捕获，我们更关注事件冒泡。 
5. 有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave 
6. 事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。

### 4. 事件对象

#### 4.1 什么是事件对象

```
eventTarget.onclick = function(event) {}
eventTarget.addEventListener('click', function(event) {}）
 // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt 
```

官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。 简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。 比如： 

1. 谁绑定了这个事件。
2. 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。
3. 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。

#### 4.2 事件对象的使用语法

```
 eventTarget.onclick = function(event) {
 // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt
 }
 eventTarget.addEventListener('click', function(event) {
 // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt
 })
```

这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去。 当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。

#### 4.3 事件对象的兼容性方案

事件对象本身的获取存在兼容问题： 1. 标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。 2. 在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。

 解决: e = e || window.event;

#### 4.4 事件对象的常见属性和方法

e.target 和 this 的区别： this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素） e.target 是事件触发的元素。

| 事件对象属性方法    | 说明                                                        |
| ------------------- | ----------------------------------------------------------- |
| e.target            | 返回触发事件的对象    标准                                  |
| e.srcElement        | 返回触发事件的对象    非标准ie6-8使用                       |
| e.type              | 返回事件的类型比如click mouseover不带on                     |
| e.cancelBubble      | 该属性阻止冒泡非标准ie6-8使用                               |
| e.returnValue       | 该属性阻止默认事件(默认行为)非标准ie6-8使用比如不让链接跳转 |
| e.preventDefault()  | 该方法阻止默认事件（默认行为)标准比如不让链接跳转           |
| e.stopPropagation() | 阻止胃泡标准                                                |

### 5. 阻止事件冒泡

#### 5.1 阻止事件冒泡的两种方式

事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。 

事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。

**阻止事件冒泡** 

- 标准写法：利用事件对象里面的 stopPropagation()方法

```
e.stopPropagation()
```

-  非标准写法：IE 6-8 利用事件对象 cancelBubble 属性

```
e.cancelBubble = true; 
```

#### 5.2 阻止事件冒泡的兼容性解决方案

```javascript
if (e && e.stopPropagation) {
    e.stopPropagation();
} else {
    window.event.cancelBubble = true;
}
```

### 6. 事件委托（代理、委派）

事件冒泡本身的特性，会带来的坏处，也会**带来的好处**，需要我们灵活掌握。生活中有如下场景： 

咱们班有100个学生， 快递员有100个快递， 如果一个个的送花费时间较长。同时每个学生领取的时候，也需 要排队领取，也花费时间较长，何如？ 

**解决方案**： 快递员把100个快递，**委托**给班主任，班主任把这些快递放到办公室，同学们下课自行领取即可。 

**优势**： 快递员省事，委托给班主任就可以走了。 同学们领取也方便，因为相信班主任。

```
<ul>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
</ul>
```

点击每个 li 都会弹出对话框，以前需要给每个 li 注册事件，是非常辛苦的，而且访问 DOM 的次数越多，这就 会延长整个页面的交互就绪时间。
**事件委托** ：事件委托也称为事件代理， 在 jQuery 里面称为事件委派。 

**事件委托的原理** ：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。 

以上案例：给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li，因为点击 li，事件会冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。 

**事件委托的作用** ：我们只操作了一次 DOM ，提高了程序的性能。

### 7. 常用的鼠标事件

#### 7.1 常用的鼠标事件

| 鼠标事件    | 触发条件               |
| ----------- | ---------------------- |
| onclick     | 鼠标点击左键触发       |
| onmouseover | 鼠标经过触发(鼠标悬浮) |
| onmouseout  | 鼠标离开触发           |
| onfocus     | 获得鼠标焦点触发       |
| onblur      | 失去鼠标焦点触发       |
| onmousemove | 鼠标移动触发           |
| onmouseup   | 鼠标弹起触发           |
| onmousedown | 鼠标按下触发           |

1.禁止鼠标右键菜单 

contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单

```
document.addEventListener('contextmenu', function (e) {
    e.preventDefault();
})
```

2.禁止鼠标选中（selectstart 开始选中）

```
document.addEventListener('selectstart', function (e) {
    e.preventDefault();
})
```

PS:vue项目使用过的实例

```
@mouseenter="cartShowState(true)"//鼠标悬浮
@mouseleave="cartShowState(false)"//鼠标离开
```



#### 7.2 鼠标事件对象

event对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象 MouseEvent 和键盘事件对象 KeyboardEvent。

| 鼠标事件对象 | 说明                                   |
| ------------ | -------------------------------------- |
| e.clientX    | 返回鼠标相对于浏览器窗口可视区的×坐标  |
| e.clientY    | 返回鼠标相对于浏览器窗口可视区的Y坐标  |
| e.pageX      | 返回鼠标相对于文档页面的X坐标 IE9+支持 |
| e.pageY      | 返回鼠标相对于文档页面的Y坐标IE9+支持  |
| e.screenX    | 返回鼠标相对于电脑屏幕的×坐标          |
| e.screenY    | 返回鼠标相对于电脑屏幕的Y坐标          |

### 8. 常用的键盘事件

#### 8.1 常用键盘事件

事件除了使用鼠标触发，还可以使用键盘触发。

| 键盘事件   | 触发条件                                                     |
| ---------- | ------------------------------------------------------------ |
| onkeyup    | 某个键盘按键被松开时触发                                     |
| onkeydown  | 某个键盘按键被按下时触发                                     |
| onkeypress | 某个键盘按键被按下时触发但是它不识别功能键比如ctrl shift 箭头等 |

注意：

1. 如果使用addEventListener 不需要加 on 
2. onkeypress 和前面2个的区别是，它不识别功能键，比如左右箭头，shift 等。 
3. 三个事件的执行顺序是： keydown -- keypress --- keyup

#### 8.2 键盘事件对象

| 键盘事件对象属性 | 说明              |
| ---------------- | ----------------- |
| keyCode          | 返回该键的ASCII值 |

**注意**： onkeydown 和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写。 

在我们实际开发中，我们更多的使用keydown和keyup， 它能识别所有的键（包括功能键） 

Keypress 不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCII值

#### 8.3 ASCII 表

![img](https://s2.loli.net/2022/08/15/tG9SrYXhxEigc3A.jpg)

PS:vue项目实例-阻止回车提交表单

```html
//阻止回车提交表单
onkeypress="return event.keyCode != 13;"//阻止提交
onkeydown="if(event.keyCode==13){return false;}"//阻止提交
onkeydown="if(event.keyCode==13){fun()}"//调用函数

v-on:keyup.enter="search()"
```

# 三.BOM浏览器对象模型

## 1. BOM 概述

### 1.1 什么是 BOM 

BOM（Browser Object Model）即**浏览器对象模型**，它提供了独立于内容而与**浏览器窗口进行交互的对象**，其核心 对象是 window。

BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。 

BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏 览器标准的一部分。

**DOM**

- 文档对象模型
- DOM就是把「文档」当做一个「对象」来看待
- DOM的顶级对象是**document**
- DOM主要学习的是操作页面元素
- DOM是 W3C标准规范

**BOM**

- 浏览器对象模型
- 把「浏览器」当做一个「对象」来看待
- BOM的顶级对象是window
- BOM学习的是浏览器窗口交互的一些对象

- BOM是浏览器厂商在各自浏览器上定义的，兼容性较差

#### 1.2 BOM 的构成

BOM 比 DOM 更大，它包含 DOM。

![image-20210218010732328](https://s2.loli.net/2022/08/15/1ZmTfuKwEFjAJDa.png)

window 对象是浏览器的顶级对象，它具有双重角色。 

1. 它是 JS 访问浏览器窗口的一个接口。 
2. 它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法。 

在调用的时候可以省略 window，前面学习的对话框都属于 window 对象方法，如 alert()、prompt() 等。 

**注意**：window下的一个特殊属性 window.name

## 2. window 对象的常见事件

### 2.1 窗口加载事件

```
window.onload = function(){}
或者
window.addEventListener("load",function(){});
```

window.onload 是窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。

 **注意**： 

1. 有了 window.onload 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕， 再去执行处理函数。
2. window.onload 传统注册事件方式 只能写一次，如果有多个，会以最后一个 window.onload 为准。 
3. 如果使用 addEventListener 则没有限制

```
document.addEventListener('DOMContentLoaded',function(){})
```

DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。 

Ie9以上才支持 

如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用 户的体验，此时用 DOMContentLoaded 事件比较合适。

### 2.2 调整窗口大小事件

```
window.onresize = function(){}
window.addEventListener("resize",function(){});
```

window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。 

**注意：** 

1. 只要窗口大小发生像素变化，就会触发这个事件。
2. 我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度

## 3. 定时器

### 3.1 两种定时器

window 对象给我们提供了 2 个非常好用的方法-定时器。

- setTimeout() 
- setInterval() 

### 3.2 setTimeout() 定时器

```
window.setTimeout(调用函数, [延迟的毫秒数]);
```

setTimeout() 方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。 

注意： 

1. window 可以省略。
2. 这个调用函数可以**直接写函数，或者写函数名**或者采取字符串**‘函数名()'**三种形式。第三种不推荐 
3. 延迟的毫秒数省略默认是 0，如果写，必须是毫秒。 
4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。

setTimeout() 这个调用函数我们也称为**回调函数 callback** 

普通函数是按照代码顺序直接调用。 

而这个函数，**需要等待**时间，时间到了才去调用这个函数，因此称为回调函数。 

简单理解： 回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。 

以前我们讲的 element.onclick = function(){} 或者 element.addEventListener(“click”, fn); 里面的 函数也是回调 函数。

### 3.3 停止 setTimeout() 定时器

```
 window.clearTimeout(timeoutID)
```

clearTimeout()方法取消了先前通过调用 setTimeout() 建立的定时器。 

**注意**： 

1. window 可以省略。
2. 里面的参数就是定时器的标识符 。

### 3.4 setInterval() 定时器

```
 window.setInterval(回调函数, [间隔的毫秒数]);
```

setInterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。 

注意： 

1. window 可以省略。
2. 这个调用函数可以**直接写函数，或者写函数名**或者采取字符串 **'函数名()'** 三种形式。
3. 间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。 
4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。
5. 第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次。

### 3.5 停止 setInterval() 定时器

```
window.clearInterval(intervalID);
```

clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。 

**注意**： 

1. window 可以省略。 
2. 里面的参数就是定时器的标识符 。

### 3.6 this

this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this 的最终指向的是那个调用它的对象 

现阶段，我们先了解一下几个this指向 

1. 全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window） 
2. 方法调用中谁调用this指向谁
3. 构造函数中this指向构造函数的实例

## 4. JS 执行机制

### 4.1 JS 是单线程

JavaScript 语言的一大特点就是**单线程**，也就是说，**同一个时间只能做一件事**。这是因为 Javascript 这门脚 本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对 某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。 

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

PS1:

```javascript
console.log(1);
setTimeout(function () {
    console.log(3);
}, 1000);
console.log(2);
//1 2 3
```

PS2:

```javascript
console.log(1);
setTimeout(function () {
    console.log(3);
}, 0);
console.log(2);
//1 2 3
```

### 4.2 同步和异步

为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创 建多个线程。于是，JS 中出现了**同步**和**异步**。 

**同步** 

前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做 法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。 

**异步** 

你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做 饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。 

**本质区别**： 这条流水线上各个流程的执行顺序不同。

### 4.3同步任务和异步任务

**同步任务** 

同步任务都在主线程上执行，形成一个**执行栈**。 

**异步任务** 

JS 的异步是通过回调函数实现的。 

一般而言，异步任务有以下三种类型: 

1. 普通事件，如 click、resize 等 

2. 资源加载，如 load、error 等 

3. 定时器，包括 setInterval、setTimeout 等 异步任务相关**回调函数**添加到**任务队列**中（任务队列也称为消息队列）。

### 4.4 JS 执行机制

1. 先执行**执行栈中的同步任务**。
2. 异步任务（回调函数）放入任务队列中。
3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取**任务队列**中的异步任务，于是被读取的异步任 务结束等待状态，进入执行栈，开始执行。
![image-20210218165354752](https://s2.loli.net/2022/08/15/RWz58bIQfq3VMJZ.png)

```javascript
console.log(1);
document.onclick = function () {
    console.log('click');
}
console.log(2);
setTimeout(function () {
    console.log(3)
}, 3000)
```

由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。

## 5. location 对象

### 5.1 什么是 location 对象

window 对象给我们提供了一个 **location 属性**用于**获取或设置窗体的 URL**，并且可以用于解析 URL 。 因为 这个属性返回的是一个对象，所以我们将这个属性也称为 **location 对象**。

### 5.2 URL

**统一资源定位符 (Uniform Resource Locator, URL)** 是互联网上标准资源的地址。互联网上的每个文件都有 一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 URL 的一般语法格式为：

```
protocol://host[:port]/path/[?query]#fragment
http://www.itcast.cn/index.html?name=andy&age=18#link
```

| 组成     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| protocol | 通信协议常用的http,ftp,maito等                               |
| host     | 主机(域名)                                                   |
| port     | 端口号可选，省略时使用方案的默认端口如http的默认端口为80     |
| path     | 路径由零或多个/符号隔开的字符串，一般用来表示主机上的一个目录或文件地址 |
| query    | 参数以键值对的形式,通过&符号分隔开来                         |
| fragment | 片段#后面内容常见于链接锚点                                  |

### 5.3 location 对象的属性

| 属性              | 描述                          |
| :---------------- | :---------------------------- |
| location.hash     | 返回一个URL的锚部分           |
| location.host     | 返回一个URL的主机名和端口     |
| location.hostname | 返回URL的主机名               |
| location.href     | 返回完整的URL                 |
| location.pathname | 返回的URL路径名。             |
| location.port     | 返回一个URL服务器使用的端口号 |
| location.protocol | 返回一个URL协议               |
| location.search   | 返回一个URL的查询部分         |

重点记住： href 和 search

### 5.4 location 对象的方法

| 方法      | 说明                                                         |
| :-------- | :----------------------------------------------------------- |
| assign()  | 跟href—样，可以跳转页面(也称为重定向页面)                    |
| reload()  | 替换当前页面，因为不记录历史，所以不能后退页面               |
| replace() | 重新加载页面，相当于刷新按钮或者f5如果参数为true强制刷新ctrl+f5 |

```javascript
window.location.href='/';//界面跳转
window.location.reload();//界面重载
```



## 6. navigator 对象

navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客 户机发送服务器的 user-agent 头部的值。 

下面前端代码可以判断用户那个终端打开页面，实现跳转

```javascript
if (
    (navigator.userAgent.match
        (/(phone|pad|pod|iPhone|iPod|ios|iPad|Android| Mobile | BlackBerry | IEMobile | MQQBrowser | JUC | Fennec | wOSBrowser | BrowserNG | WebOS | Symbian | Windows Phone) /i)
    )) {
    window.location.href = ""; //手机
} else {
    window.location.href = ""; //电脑
}
```

## 7. history 对象

window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中） 访问过的 URL。

| 方法      | 说明                                    |
| :-------- | :-------------------------------------- |
| back()    | 加载 history 列表中的前一个 URL（后退） |
| forward() | 加载 history 列表中的下一个 URL（前进） |
| go()      | 加载 history 列表中的某个具体页面       |

history 对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。

# 四.PC端网页特效

## 1. 元素偏移量 offset 系列

### 1.1 offset 概述

offset 翻译过来就是偏移量， 我们使用 offset 系列相关属性可以动态的得到该元素的位置（偏移）、大小等。 

- 获得元素距离带有定位父元素的位置 
- 获得元素自身的大小（宽度高度） 
- 注意： 返回的数值都不带单位 1.1 offset 概述 

offset 系列常用属性：

| offset系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.offsetParent | 返回作为该元素带有定位的父级元素如果父级都没有定位则返回body |
| element.offsetTop    | 返回元素相对带有定位父元素上方的偏移                         |
| element.offsetLeft   | 返回元,素相对带有定位父元,素左边框的偏移                     |
| element.offsetWidth  | 返回自身包括padding、边框、内容区的宽度，返回数值不带单位    |
| element.offsetHeight | 返回自身包括padding、边框、内容区的高度，返回数值不带单位    |

### 1.2 offset 与 style 区别

**offset**

- offset可以得到任意样式表中的样式值
- offset系列获得的数值是没有单位的
- offsetWidth包含padding+border+width
- offsetWidth等属性是只读属性，只能获取不能赋值
- **所以，我们想要获取元素大小位置，用offset更合适**

**style**

- style 只能得到行内样式表中的样式值
- style.width获得的是带有单位的字符串
- style.width 获得不包含padding和border的值
- style.width是可读写属性，可以获取也可以赋值
- **所以，我们想要给元素更改值，则需要用style改变**

## 2. 元素可视区 client 系列

**client** 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列 的相关属性可以动态的得到该元素的边框大小、元素大小等。

| client系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.clientTop    | 返回元素上边框的大小                                         |
| element.clientLeft   | 返回元素左边框的大小                                         |
| element.clientWidth  | 返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位 |
| element.clientHeight | 返回自身包括padding、内容区的高度，不含边框，返回数值不带单位 |

## 3. 元素滚动 scroll 系列

### 3.1元素 scroll 系列属性

**scroll** 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。

| scroll系列属性       | 作用                                           |
| -------------------- | ---------------------------------------------- |
| element.scrollTop    | 返回被卷去的上侧距离，返回数值不带单位         |
| element.scrollLeft   | 返回被卷去的左侧距离，返回数值不带单位         |
| element.scrollWidth  | 返回自身实际的宽度，不含边框，返回数值不带单位 |
| element.scrollHeight | 返回自身实际的高度，不含边框，返回数值不带单位 |

### 3.2页面被卷去的头部

如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏 掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll 事件。

### 3.3页面被卷去的头部兼容性解决方案

需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法:

1. 声明了DTD，使用document.documentElement.scrollTop
2. 未声明DTD，使用document. body.scrollTop
3. 新方法window.pageYoffset和window.pagexoffset，IE9开始支持

```javascript
function getScroll() {
    return {
        left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0,
        top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
    };
}
// 使用的时候 getScroll().left
```

### 3.4三大系列总结

| 三大系列大小对比    | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| element.offsetWidth | 返回自身包括padding、边框、内容区的宽度，返回数值不带单位    |
| element.clientWidth | 返回自身包括padding 、内容区的宽度，不含边框，返回数值不带单位 |
| element.scrollWidth | 返回自身实际的宽度，不含边框，返回数值不带单位               |

![img](https://s2.loli.net/2022/08/15/y5I9zUCTPqr2DAN.png)

他们主要用法：

1. offset系列 经常用于获得元素位置 **offsetLeft offsetTop**
2. client 经常用于获取元素大小 **clientWidth clientHeight**
3. scroll 经常用于获取滚动距离 **scrollTop scrollLeft** 
4. **注意页面滚动的距离通过** window.pageXOffset 获得

### 3.5mouseenter 和mouseover的区别

**mouseenter 鼠标事件**

- 当鼠标移动到元素上时就会触发mouseenter事件
- 类似mouseover，它们两者之间的差别是
- mouseover鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter 只会经过自身盒子触发
- 之所以这样，就是因为mouseenter不会冒泡
- 跟mouseenter搭配鼠标离开mouseleave同样不会冒泡

## 4. 动画函数封装

### 4.1 动画实现原理

**核心原理**：通过定时器 setInterval() 不断移动盒子位置。 

实现步骤： 

1. 获得盒子当前位置 
2. 让盒子在当前位置加上1个移动距离
3. 利用定时器不断重复这个操作
4. 加一个结束定时器的条件
5. 注意此元素需要添加定位，才能使用element.style.left

### 4.2 动画函数简单封装

注意函数需要传递2个参数，**动画对象**和**移动到的距离**。

### 4.3 动画函数给不同元素记录不同定时器

如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自 己专门用自己的定时器）。

核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。

### 4.4 缓动效果原理

缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来 

思路： 

1. 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。 
2. 核心算法： (目标值 - 现在的位置 ) / 10 做为每次移动的距离 步长 
3. 停止的条件是： 让当前盒子位置等于目标位置就停止定时器 
4. 注意步长值需要取整 

#### 4.5 动画函数多个目标值之间移动

可以让动画函数从 800 移动到 500。 

当我们点击按钮时候，判断步长是正值还是负值 

1. 如果是正值，则步长 往大了取整 
2. 如果是负值，则步长 向小了取整

### 4.6 动画函数添加回调函数

**回调函数原理**：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后， 再执行传进去的这个函数，这个过程就叫做**回调**。 

回调函数写的位置：定时器结束的位置。

### 4.7 动画函数封装到单独JS文件里面

因为以后经常使用这个动画函数，可以单独封装到一个JS文件里面，使用的时候引用这个JS文件即可。

1. 单独新建一个JS文件。 
2. HTML文件引入 JS 文件。

## 5. 常见网页特效案例

### 5.1 节流阀

防止轮播图按钮连续点击造成播放过快。 

节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。 

核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。 

开始设置一个变量 var flag = true; 

If(flag) {flag = false; do something} 关闭水龙头 

利用回调函数 动画执行完毕， flag = true 打开水龙头

# 五.移动端特效

## 1. 触屏事件

### 1.1 触屏事件概述

移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动 端也有自己独特的地方。比如**触屏事件 touch**（也称触摸事件），Android 和 IOS 都有。 

touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控 笔）对屏幕或者触控板操作。 常见的触屏事件如下：

| 触屏touch事件 | 说明                          |
| ------------- | ----------------------------- |
| touchstart    | 手指触摸到一个DOM元素时触发   |
| touchmove     | 手指在一个DOM元素上滑动时触发 |
| touchend      | 手指从一个DOM元素上移开时触发 |

### 1.2 触摸事件对象（TouchEvent）

TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多 个触点，使开发者可以检测触点的移动，触点的增加和减少，等等 

touchstart、touchmove、touchend 三个事件都会各自有事件对象。 

触摸事件对象重点我们看三个常见对象列表：

| 触摸列表       | 说明                                             |
| -------------- | ------------------------------------------------ |
| touches        | 正在触摸屏幕的所有手指的一个列表                 |
| targetTouches  | 正在触摸当前DOM元素上的手指的一个列表            |
| changedTouches | 手指状态发生了改变的列表，从无到有，从有到无变化 |

**因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes**

### 1.3 移动端拖动元素

1. touchstart、touchmove、touchend 可以实现拖动元素 
2. 但是拖动元素需要当前手指的坐标值 我们可以使用 targetTouches[0] 里面的pageX 和 pageY 
3. 移动端拖动的原理： 手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离 
4. 手指移动的距离： 手指滑动中的位置 减去 手指刚开始触摸的位置 

拖动元素三步曲： 

1. 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置 
2. 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子 
3. 离开手指 touchend

注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();

## 2. 移动端常见特效

### 2.1 classList 属性

classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。 

该属性用于在元素中添加，移除及切换 CSS 类。有以下方法

**添加类**： element.classList.add（’类名’）；

```
 focus.classList.add('current'); 
```

**移除类**： element.classList.remove（’类名’）;

```
focus.classList.remove('current');
```

**切换类**： element.classList.toggle（’类名’）；

```
focus.classList.toggle(‘current’);
```

注意以上方法里面，所有类名都不带点

### 2.2 click 延时解决方案

移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。 

解决方案：  

1. 禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉 300ms 的点击延迟。

```
<meta name="viewport" content="user-scalable=no">
```

2. 利用touch事件自己封装这个事件解决 300ms 延迟。 

原理就是： 

- 当我们手指触摸屏幕，记录当前触摸时间 
- 当我们手指离开屏幕， 用离开的时间减去触摸的时间
- 如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击

```javascript
//封装tap，解决click 300ms 延时
function tap(obj, callback) {
    var isMove = false;
    var startTime = 0; // 记录触摸时候的时间变量
    obj.addEventListener('touchstart', function (e) {
        startTime = Date.now(); // 记录触摸时间
    });
    obj.addEventListener('touchmove', function (e) {
        isMove = true; // 看看是否有滑动，有滑动算拖拽，不算点击
    });
    obj.addEventListener('touchend', function (e) {
        if (!isMove && (Date.now() - startTime) < 150) { // 如果手指触摸和离开时间小于150ms 算点击 
            callback && callback(); // 执行回调函数 
        }
        isMove = false; // 取反 重置 
        startTime = 0;
    });
}
//调用 
tap(div, function () { /* 执行代码  */ });
```

3. 使用插件。 fastclick 插件解决 300ms 延迟。

## 3. 移动端常用开发插件

### 3.1 什么是插件

移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢？

 JS 插件是 js 文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件。 

特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。 我们以前写的animate.js 也算一个最简单的插件 

### 3.2 插件的使用

1. 引入js插件文件。
2. 按照规定语法使用。

fastclick 插件解决300ms延迟。使用延时
GitHub官网地址: https://github.com/ftlabs/fastclick

```javascript
if ('addEventListener' in document) {
    document.addEventListener('DOMContentLoaded', function () {
        FastClick.attach(document.body);
    }, false);
}
```

### 3.3 Swiper 插件的使用

中文官网地址： https://www.swiper.com.cn/ 

1. 引入插件相关文件。 
2. 按照规定语法使用

### 3.4 其他移动端常见插件

- superslide： http://www.superslide2.com/ 
- iscroll： https://github.com/cubiq/iscroll

### 3.5 插件的使用总结

1. 确认插件实现的功能 
2. 去官网查看使用说明 
3. 下载插件
4. 打开demo实例文件，查看需要引入的相关文件，并且引入 
5. 复制demo实例文件中的结构html，样式css以及js代码

### 3.6 练习-移动端视频插件 zy.media.js

- H5 给我们提供了 video 标签，但是浏览器的支持情况不同。 
- 不同的视频格式文件，我们可以通过source 解决。 
- 但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决。 
- 这个时候我们可以使用插件方式来制作。

## 4. 移动端常用开发框架

### 4.1 框架概述

**框架**，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架 本身，使用者要按照框架所规定的某种规范进行开发。

**插件**一般是为了解决某个问题而专门存在，其功能单一，并且比较小。 

- 前端**常用的框架**有 **Bootstrap**、**Vue**、**Angular**、**React** 等。既能开发PC端，也能开发移动端 
- 前端**常用的移动端插件**有 **swiper**、**superslide**、**iscroll**等。
- 框架： 大而全，一整套解决方案 
- 插件： 小而专一，某个功能的解决方案

### 4.2 Bootstrap

Bootstrap 是一个简洁、直观、强悍的前端开发框架，它让 web 开发更迅速、简单。 

它能开发PC端，也能开发移动端 

Bootstrap JS插件使用步骤： .

1. 引入相关js 文件 
2. 复制HTML 结构 
3. 修改对应样式 
4. 修改相应JS 参数

# 六.本地存储

## 1. 本地存储

随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经 常性在本地存储大量的数据，HTML5规范提出了相关解决方案。

本地存储特性 

1. 数据存储在用户浏览器中 
2. 设置、读取方便、甚至页面刷新不丢失数据 
3. 容量较大，sessionStorage约5M、localStorage约20M 
4. 只能存储字符串，可以将对象JSON.stringify() 编码后存储

## 2. window.sessionStorage

1. 生命周期为关闭浏览器窗口 
2. 在同一个窗口(页面)下数据可以共享 
3. 以键值对的形式存储使用

**存储数据**：

```
sessionStorage.setItem(key, value)
```

**获取数据**： 

```
sessionStorage.getItem(key)
```

**删除数据**： 

```
sessionStorage.removeItem(key) 
```

**删除所有数据**

```
sessionStorage.clear() 
```

## 3. window.localStorage

1. 声明周期永久生效，除非手动删除 否则关闭页面也会存在
2. 可以多窗口（页面）共享（同一浏览器可以共享） 
3. 以键值对的形式存储使用

**存储数据**：

```
localStorage.setItem(key, value)
```

**获取数据**： 

```
localStorage.getItem(key)
```

**删除数据**： 

```
localStorage.removeItem(key) 
```

**删除所有数据**

```
localStorage.clear() 
```

## 4.小结

```javascript
//localStorage:关闭浏览器窗口缓存数据不清除
window.localStorage.setItem("goodsInfo", JSON.stringify(obj));
window.localStorage.setItem(key,value);//设置指定 key 的数据（JSON 格式）
window.localStorage.getItem(key);//获取指定 key 的数据
window.localStorage.removeItem(key);//删除指定 key 的数据
window.localStorage.clear();//清空所有的存储数据
//sessionStorage:关闭浏览器窗口缓存数据会被清除
window.sessionStorage.setItem(key,value);
window.sessionStorage.getItem(key);
window.sessionStorage.removeItem(key);
window.sessionStorage.clear();
```

